const bcyrpt = require("bcrypt");
const jwt = require("jsonwebtoken");

/**
 *
 * Shared Class to implement common operatons
 *
 */
class Shared {
  /**
   * This method is designed to parse validation errors generated by mongoose or
   * a custom source. This method will accept strings encoded for url safety
   * by `encodeURIComponent` in the format:
   * "prop:msg, prop:msg, prop:msg"
   *          or
   * "ValidationError: prop:msg, prop:msg, prop:msg"
   * This method will then parse these formats into JSON
   * @param {} errMsg
   * @returns JSON representing validation errors
   */
  static JsonifyValididationError(errMsg) {
    if (typeof errMsg === "undefined") {
      return false;
    } else if (typeof errMsg === "null") {
      return false;
    }

    let validationError = decodeURIComponent(errMsg);

    //cut off the prefix ValidationError:
    if (validationError.substring(0, 16) === "ValidationError:") {
      validationError = validationError
        .substring(17, validationError.length)
        .split(",");
    } else {
      validationError = validationError.split(",");
    }

    let result = {};
    validationError.forEach(msg => {
      let parts = msg.split(":");
      result[parts[0].trim()] = parts[1].trim();
    });

    return result;
  }

  /**
   * Method to hash a string like a passord when a new user is registered
   *
   * @param {*} str
   */
  static hashString(str) {
    let salt = Bcyrpt.genSaltSync(process.env.SALT || 5);
    return Bcyrpt.hashSync(str, salt);
  }

  /**
   *
   * Method to compare a string to a hash to tell if they match
   *
   * @param {*} str
   * @param {*} hash
   */
  static compareHash(str, hash) {
    return bcyrpt.compareSync(str, hash);
  }

  /**
   * Method generates a token based on a given
   *  @returns a token or false if signing fails
   *
   * @param {*} payload
   */
  static tokenGen(payload) {
    let result;
    try {
      result = jwt.sign(payload, process.env.secretKey || "SuperSecretKey");
    } catch (err) {
      result = false;
    }
    return result;
  }

  /**
   * Method checks the validity of a token
   *  @returns decoded token otherwise false
   *
   * @param {*} token
   */
  static tokenCheck(token) {
    let result;

    try {
      result = jwt.verify(token, process.env.secretKey || "SuperSecretKey");
    } catch (err) {
      result = {
        auth: false
      };
    }
    return result;
  }
  /**
   * Method designed to escape html in a string
   * @param {*} text
   */
  static escapeHtml(text) {
    var map = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
    };

    return text.replace(/[&<>"']/g, function (m) {
      return map[m];
    });
  }
}

module.exports = Shared;
